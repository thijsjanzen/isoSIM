---
title: "Walkthrough"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Walkthrough}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=6) 
```

# ISOSIM
The package isoSIM was designed to simulate the generation of iso-female lines, and simulate genomic changes during, and after, formation of iso-female lines. Furthermore, it allows for simulation of effects after crossing individuals from iso-female lines.

```{r}
library(isoSIM)
library(ggplot2)
packageVersion("isoSIM")
```


## Simulating an iso-female line
In order to create an iso-female line, we first have to create a 'wild' population, from which we will draw individuals. To create such a population, we make use of the function 'create_population':
```{r create wildpop}
wildpop =  create_population(pop_size = 100, 
                             number_of_founders = 4,
                             total_runtime = 1000, 
                             morgan = 1, 
                             seed = 42)

```
This creates a population of 100 diploid individuals (e.g. 2N = 200), based upon 10 founders (e.g. 10 individuals that can be genetically distinguished from each other). Then, for 1000 generations, this population is inbred and genomes of the 20 founders are allowed to mix. All individuals have 2 chromosomes (for simplicity and computational speed, we only model one chromosome pair), which are 1 Morgan long. The result can be written to file (optional), which can be usefull when generating for instance an extremely large wild population, which can be used later (e.g. read from file).

The result of the function is a structure containing 1000 individuals:
```{r}
wildpop
```
Each individual has two chromosomes, with a given number of junctions (e.g. delineations between two contiguous genomic stretches from different ancestors):
```{r}
wildpop[[1]]
```

In order to create an iso-female line, two random individuals are drawn from the wild population, and selected for inbreeding. We can simulate this process with:
```{r create isofemale}
isofemale <- create_iso_female(source_pop = wildpop,
                               n = 1,
                               inbreeding_pop_size = 100,
                               run_time = 2000,
                               morgan = 1)
```

Here, n indicates the number of isofemales to be created from the same source population, the inbreeding population size is set to be small, in order to speed up computation. Maximum run time is best set hight, to assure that all individuals become genetically identical. 

# Visualizing individuals
Now, we can plot the isofemales, this plots the two chromosomes next to each other, where colors indicate different ancestors:
```{r}
plot(isofemale[[1]])
```

Because we have chosen 4 ancestors, these plots are not terribly informative, let's try a toy example:
```{r toyexample}
wildpop =  create_population(pop_size = 100, 
                             number_of_founders = 2,
                             total_runtime = 10, 
                             morgan = 1, 
                             seed = 666)

isofemale <- create_iso_female(source_pop = wildpop,
                               n = 1,
                               inbreeding_pop_size = 100,
                               run_time = 10000,
                               morgan = 1)
plot(wildpop[[1]])
plot(isofemale[[1]])
```

We can also plot a (section of) a single chromosome:
```{r plot selection of chromosome}
plot_chromosome(isofemale[[1]]$chromosome1, xmin = 0.0, xmax = 0.5)
```

# Multiple source populations

It gets more interesting if we create two populations, and draw iso-females from them, and cross these.
First, we have to create two populations. 
```{r create two populations}
two_populations <- create_two_populations(pop_size = 1000, 
                                          number_of_founders = 20,
                                          total_runtime = 10, 
                                          morgan = 1, 
                                          seed = 42,
                                          overlap = 0.25)
```
Syntax to create two populations is identical to creating one, save the parameter 'overlap'. This determines the fraction of founders shared by the two populations. 

Now that we have two populations, we can generate two different iso-females from them:
```{r draw two isofemales}
isofemales <- create_iso_female(source_pop = two_populations$Population_1,
                               n = 2,
                               inbreeding_pop_size = 100,
                               run_time = 10000,
                               morgan = 1)

par(mfrow=c(1,2))
plot_chromosome(isofemales[[1]]$chromosome1, 0, 1)
plot_chromosome(isofemales[[2]]$chromosome1, 0, 1)
```

We can now use these two isofemales to seed a new inbreeding population:
```{r seed mixed population}
mixed_population <- create_population_from_individuals(list(isofemales[[1]], isofemales[[2]]),
                                                       pop_size = 100, total_runtime = 100,
                                                       morgan = 1, seed = 42)

```
And plot some individuals from our new population:
```{r plot mixed_population}
plot(mixed_population[[1]])
```

# Statistics

## FST
We can show the effect of overlap by calculating the Fst value:
```{r calc FST}

FST <- calculate_fst(two_populations$Population_1,
                 two_populations$Population_2,
                 sampled_individuals = 10,
                 number_of_markers = 100,
                 random_markers = TRUE)
FST
```
The FST calculation function uses the library hierfstat to calculate the FST. To do so, it samples 10 random individuals (the parameter sampled individuals) from the population, and then assesses the genetic content at 100 randomly placed markers (number of markers, and random_markers = TRUE). To increase power, a higher number of individuals can be sampled, although this does increase computational load.

Although this seems to be quite right, I have no right intuition how the FST should relate to the overlap - I thought it would be inversely related (FST = 1 - overlap) but this doesn't hold. Either my intuition is wrong, or I calculate the FST wrongly...

## LD
We can also calculate LD statistics. LD is only defined for markers, so again we have to simulate artificial markers along the chromosome. 

```{r}
  LD_results <- calculate_LD(wildpop, number_of_markers = 10, random_markers = TRUE)

  par(mfrow=c(1,3))
  plot(LD_results$LD_matrix~LD_results$dist_matrix, xlab = "Genetic Distance (Morgan)", ylab = "LD", pch = 16)
  plot(LD_results$rsq_matrix~LD_results$dist_matrix, xlab = "Genetic Distance (Morgan)", ylab = "r_sq", pch = 16)
  plot(LD_results$LD_matrix~LD_results$rsq_matrix, xlab = "r_sq", ylab = "LD", pch = 16)
```

To analyze LD patterns better, it makes more sense to create a population from scratch. We expect for a strongly inbred population, that there is no LD:

```{r no LD}
no_LD_pop <- create_population(pop_size = 100, 
                             number_of_founders = 4,
                             total_runtime = 1000, 
                             morgan = 1, 
                             seed = 42)

LD_results <- calculate_LD(no_LD_pop, sampled_individuals = 10,
                                  number_of_markers = 10, random_markers = TRUE)

par(mfrow=c(1,1))
par(mar=c(4,4,2,2))
plot(LD_results$LD_matrix~LD_results$dist_matrix, pch = 16, xlab = "Distance", ylab = "LD",xlim = c(0, 1), ylim = c(0, 1))
```

Alternatively, for a barely inbred population, we expect a negative relationship between LD and distance:

```{r strong LD}
strong_LD_pop <- create_population(pop_size = 1000, 
                             number_of_founders = 4,
                             total_runtime = 10, 
                             morgan = 1, 
                             seed = 42)

LD_results <- isoSIM::calculate_LD(strong_LD_pop, sampled_individuals = 10,
                                  number_of_markers = 10, random_markers = TRUE)

par(mfrow=c(1,1))
par(mar=c(4,4,2,2))
plot(LD_results$LD_matrix~LD_results$dist_matrix, pch = 16, xlab = "Distance", ylab = "LD",xlim = c(0, 1), ylim = c(0, 1))
```

# Selection
Selection for specific markers (e.g. SNPs) can potentially cause local allelel frequency biases, and influence genetic patterns within the population as a whole.
Here we provide two different methods of invoking selection: on markers, and on regions within the genome.

## Marker based selection
Here, genetic content of a specific ancestor at a genetic marker is assumed to provide a fitness benefit of *s*, such that individuals with genetic material of another ancestor at that marker have fitness 1, and individuals with matching ancestral material fitness *1+s*. 
The user can specify markers by providing a selection matrix with one column for *location*, *ancestor* and *s* respectively.

```{r selection_markers from scratch}
selection_matrix = matrix(ncol=3, nrow = 1)

selection_matrix[1,] = c(0.5, 0, 1)

selected_pop <- create_population_selection(pop_size = 1000,
                                  number_of_founders = 4, 
                                  total_runtime = 500,
                                  morgan = 1,
                                  select_matrix = selection_matrix,
                                  seed = 12345)

freq_output <- calculate_allele_frequencies(selected_pop$population, 
                                            step_size = 0.001)

ggplot(freq_output, aes(x=location, y = frequency, col = as.factor(ancestor))) +
  geom_line() +
  geom_vline(xintercept = c(0.5), lty = 2)

```
From the allele frequency graph it is clear that around the location 0.5, the frequency of genetic material of ancestor 0 increases a lot. 

Alternatively, we can assess allele frequency exactly at the marker position:
```{r marker frequency}
# at the selected marker
calculate_marker_frequency(selected_pop$population, 0.5)

# at a neutral marker
calculate_marker_frequency(selected_pop$population, 0.8)
```

Contrasting selection on a novel population, we also provide code to impose selection on an already existing population.

```{r selection markers_with_previous_population}
number_founders = 4
wildpop =  create_population(pop_size = 1000, 
                             number_of_founders = number_founders,
                             total_runtime = 10, 
                             morgan = 1, 
                             seed = 666)

selection_matrix = matrix(ncol=3, nrow = 1)
selection_matrix[1,] = c(0.5, 0, 1)

selected_pop <- select_population(wildpop, 
                                  selection_matrix,
                                  pop_size = 1000,
                                  total_runtime = 500,
                                  morgan = 1,
                                  seed = 12345)

freq_output <- calculate_allele_frequencies(selected_pop$population, 
                                            step_size = 0.001)

ggplot(freq_output, aes(x=location, y = frequency, col = as.factor(ancestor))) +
  geom_line() +
  geom_vline(xintercept = c(0.5), lty = 2)

```

# Non additive selection
In the previous section we considered selection to be fully additive, such that the fitness matrix for genotypes aa, aA and AA was given by *1*, *1+0.5xs*, *1+s*. Here, the genotype 'aa' represents the wildtype genome, where the ancestor under selection is not present at the focal marker. Similarly, 'AA' represents a genome homozygous for the ancestor under selection, and 'Aa' is the heterozygote. 
This approach was chosen to minimise user input. Alternatively, the user can specify it's own fitness matrix. Let us first explore whether this code works identical to the previous code. 
```{r two_alleles test}

  s <- 0.1

  selection_matrix = matrix(ncol=3, nrow = 1)
  selection_matrix[1,] = c(0.5, 0, s)

  selected_pop_1 <- create_population_selection(pop_size = 1000,
                                                number_of_founders = 10,
                                                total_runtime = 100,
                                                morgan = 1,
                                                select_matrix = selection_matrix,
                                                seed = 12345,
                                                track_frequency = TRUE)

  selection_matrix = matrix(ncol=5, nrow = 1)
  selection_matrix[1,] = c(0.5, 
                           1.0, 1.0 + 0.5 * s, 1.0 + s, 
                           0)

  selected_pop_2 <- create_population_selection_twoalleles(pop_size = 1000,
                                                           number_of_founders = 10,
                                                           total_runtime = 100,
                                                           morgan = 1,
                                                           select_matrix = selection_matrix,
                                                           seed = 12345,
                                                           track_frequency = TRUE)

  testthat::expect_true(all.equal(selected_pop_1, selected_pop_2));

ggplot(selected_pop_1$frequencies, aes(y = frequency, x = time, col = as.factor(ancestor))) + geom_line() + ylim(0,1) + ggtitle("Additive selection")

  ggplot(selected_pop_2$frequencies, aes(y = frequency, x = time, col = as.factor(ancestor))) + geom_line() + ylim(0,1) + ggtitle("User specificied selection")
```

Both simulations provide the exact same output, which is to be expected because they both use the same fitness matrix, and the same random number seed. 

A perhaps more interesting simulation would be one where the heterozygote has an advantage over the other genotypes
```{r heterozygote selection}
selection_matrix[1,] = c(0.5, 
                           1.0, 1.0 + s, 1.0, 
                           0)

  selected_pop <- create_population_selection_twoalleles(pop_size = 1000,
                                                           number_of_founders = 2,
                                                           total_runtime = 100,
                                                           morgan = 1,
                                                           select_matrix = selection_matrix,
                                                           seed = 12345,
                                                           track_frequency = TRUE)

ggplot(selected_pop$frequencies, aes(y = frequency, x = time, col = as.factor(ancestor))) + geom_line() + ylim(0,1)
```

Indeed we observe that the frequencies of both ancestors are in equilibrium around 0.5, as expected.

Lastly, an interesting simulation would be where we give only the homozygous mutant a selective benefit. Here we expect that it takes some time before the homozygote takes over.

```{r homozygote selection}
selection_matrix[1,] = c(0.5, 
                           1.0, 1.0, 1.0 + s, 
                           0)

  selected_pop <- create_population_selection_twoalleles(pop_size = 1000,
                                                           number_of_founders = 10,
                                                           total_runtime = 300,
                                                           morgan = 1,
                                                           select_matrix = selection_matrix,
                                                           seed = 12345,
                                                           track_frequency = TRUE)

ggplot(selected_pop$frequencies, aes(y = frequency, x = time, col = as.factor(ancestor))) + geom_line() + ylim(0,1)
```


# Migration
To simulate two populations with a fixed degree of migration between them, we can use:

```{r}
pops_migration <- create_two_populations_migration(pop_size = 1000,
                                         number_of_founders = 4,
                                         total_runtime = 100,
                                         morgan = 1,
                                         seed = 1234,
                                         migration = 0.01)
```
This creates two populations, where with a probability of 0.01 (e.g. 'migration') offspring in the next generation is the product of a mating event of two randomly picked individuals from the other population.

FST values drop rapidly depending on the rate of migration, migration of 0.01 already decreases FST to about 0 in 100 generations:
```{r}
FST <- calculate_fst(pops_migration$Population_1,
                 pops_migration$Population_2,
                 sampled_individuals = 10,
                 number_of_markers = 100,
                 random_markers = TRUE)
FST
```