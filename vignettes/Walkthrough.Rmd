---
title: "Walkthrough"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Walkthrough}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=6) 
```

# ISOSIM
The package isoSIM was designed to simulate the generation of iso-female lines, and simulate genomic changes during, and after, formation of iso-female lines. Furthermore, it allows for simulation of effects after crossing individuals from iso-female lines.

```{r}
library(isoSIM)
library(ggplot2)
```


## Simulating an iso-female line
In order to create an iso-female line, we first have to create a 'wild' population, from which we will draw individuals. To create such a population, we make use of the function 'create_population':
```{r create wildpop}
wildpop =  create_population(pop_size = 100, 
                             number_of_founders = 10,
                             total_runtime = 1000, 
                             morgan = 1, 
                             seed = 42, 
                             write_to_file = FALSE)

```
This creates a population of 100 diploid individuals (e.g. 2N = 200), based upon 10 founders (e.g. 10 individuals that can be genetically distinguished from each other). Then, for 1000 generations, this population is inbred and genomes of the 20 founders are allowed to mix. All individuals have 2 chromosomes (for simplicity and computational speed, we only model one chromosome pair), which are 1 Morgan long. The result can be written to file (optional), which can be usefull when generating for instance an extremely large wild population, which can be used later (e.g. read from file).

The result of the function is a structure containing 1000 individuals:
```{r}
wildpop
```
Each individual has two chromosomes, with a given number of junctions (e.g. delineations between two contiguous genomic stretches from different ancestors):
```{r}
wildpop[[1]]
```

In order to create an iso-female line, two random individuals are drawn from the wild population, and selected for inbreeding. We can simulate this process with:
```{r create isofemale}
isofemale <- create_iso_female(source_pop = wildpop,
                               n = 1,
                               inbreeding_pop_size = 100,
                               run_time = 1000000,
                               morgan = 1)
```

Here, n indicates the number of isofemales to be created from the same source population, the inbreeding population size is set to be small, in order to speed up computation. Maximum run time is best set hight, to assure that all individuals become genetically identical. 

# Visualizing individuals
Now, we can plot the isofemales, this plots the two chromosomes next to each other, where colors indicate different ancestors:
```{r}
plot(isofemale[[1]])
```

Because we have chosen 10 ancestors, these plots are not terribly informative, let's try a toy example:
```{r toyexample}
wildpop =  create_population(pop_size = 100, 
                             number_of_founders = 2,
                             total_runtime = 10, 
                             morgan = 1, 
                             seed = 666, 
                             write_to_file = FALSE)

isofemale <- create_iso_female(source_pop = wildpop,
                               n = 1,
                               inbreeding_pop_size = 100,
                               run_time = 1000000,
                               morgan = 1)
plot(wildpop[[1]])
plot(isofemale[[1]])
```

We can also plot a (section of) a single chromosome:
```{r plot selection of chromosome}
plot_chromosome(isofemale[[1]]$chromosome1, xmin = 0.0, xmax = 0.5)
```

# Multiple source populations

It gets more interesting if we create two populations, and draw iso-females from them, and cross these.
First, we have to create two populations. 
```{r create two populations}
two_populations <- create_two_populations(pop_size = 1000, 
                                          number_of_founders = 20,
                                          total_runtime = 10, 
                                          morgan = 1, 
                                          seed = 42,
                                          overlap = 0.25, 
                                          write_to_file = FALSE)
```
Syntax to create two populations is identical to creating one, save the parameter 'overlap'. This determines the fraction of founders shared by the two populations. 

Now that we have two populations, we can generate two different iso-females from them:
```{r draw two isofemales}
isofemales <- create_iso_female(source_pop = two_populations$Population_1,
                               n = 2,
                               inbreeding_pop_size = 100,
                               run_time = 1000000,
                               morgan = 1)

par(mfrow=c(1,2))
plot_chromosome(isofemales[[1]]$chromosome1, 0, 1)
plot_chromosome(isofemales[[2]]$chromosome1, 0, 1)
```

We can now use these two isofemales to seed a new inbreeding population:
```{r seed mixed population}
mixed_population <- create_population_from_individuals(list(isofemales[[1]], isofemales[[2]]),
                                                       pop_size = 100, total_runtime = 100,
                                                       morgan = 1, seed = 42, write_to_file = FALSE)

```
And plot some individuals from our new population:
```{r plot mixed_population}
#plot(mixed_population[[1]])
```

# Statistics

## FST
We can show the effect of overlap by calculating the Fst value:
```{r calc FST}

FST <- calculate_fst(two_populations$Population_1,
                 two_populations$Population_2,
                 sampled_individuals = 10,
                 number_of_markers = 100,
                 random_markers = TRUE)
FST
```
The FST calculation function uses the library hierfstat to calculate the FST. To do so, it samples 10 random individuals (the parameter sampled individuals) from the population, and then assesses the genetic content at 100 randomly placed markers (number of markers, and random_markers = TRUE). 

Although this seems to be quite right, I have no right intuition how the FST should relate to the overlap - I thought it would be inversely related (FST = 1 - overlap) but this doesn't hold. Either my intuition is wrong, or I calculate the FST wrongly...

## LD
We can also calculate LD statistics. LD is only defined for markers, so again we have to simulate artificial markers along the chromosome. 

```{r}
  LD_results <- calculate_LD(wildpop, number_of_markers = 10, random_markers = TRUE)

  par(mfrow=c(1,3))
  plot(LD_results$LD_matrix~LD_results$dist_matrix, xlab = "Genetic Distance (Morgan)", ylab = "LD", pch = 16)
  plot(LD_results$rsq_matrix~LD_results$dist_matrix, xlab = "Genetic Distance (Morgan)", ylab = "r_sq", pch = 16)
  plot(LD_results$LD_matrix~LD_results$rsq_matrix, xlab = "r_sq", ylab = "LD", pch = 16)
```

To analyze LD patterns better, it makes more sense to create a population from scratch. We expect for a strongly inbred population, that there is no LD:

```{r no LD}
no_LD_pop <- create_population(pop_size = 100, 
                             number_of_founders = 10,
                             total_runtime = 1000, 
                             morgan = 1, 
                             seed = 42, 
                             write_to_file = FALSE)

LD_results <- calculate_LD(no_LD_pop, sampled_individuals = 10,
                                  number_of_markers = 10, random_markers = TRUE)

par(mfrow=c(1,1))
par(mar=c(4,4,2,2))
plot(LD_results$LD_matrix~LD_results$dist_matrix, pch = 16, xlab = "Distance", ylab = "LD",xlim = c(0, 1), ylim = c(0, 1))
```

Alternatively, for a barely inbred population, we expect a negative relationship between LD and distance:

```{r strong LD}
strong_LD_pop <- create_population(pop_size = 1000, 
                             number_of_founders = 10,
                             total_runtime = 10, 
                             morgan = 1, 
                             seed = 42, 
                             write_to_file = FALSE)

LD_results <- isoSIM::calculate_LD(strong_LD_pop, sampled_individuals = 10,
                                  number_of_markers = 10, random_markers = TRUE)

par(mfrow=c(1,1))
par(mar=c(4,4,2,2))
plot(LD_results$LD_matrix~LD_results$dist_matrix, pch = 16, xlab = "Distance", ylab = "LD",xlim = c(0, 1), ylim = c(0, 1))
```

# Selection
Selection for genomic material of a particular ancestor can affect found patterns. isoSIM provides tools to implement such selection pressures. 
Starting from a wild population, we can simulate inbreeding with selection, in the following manner:
```{r selection}
number_founders = 20
wildpop =  create_population(pop_size = 1000, 
                             number_of_founders = number_founders,
                             total_runtime = 10, 
                             morgan = 1, 
                             seed = 666, 
                             write_to_file = FALSE)

selection_matrix = matrix(ncol=3, nrow = 2)

selection_matrix[1,] = c(0.2, 0.3, 1)
selection_matrix[2,] = c(0.6, 0.7, 2)

selection_coefficient <- 1 #we choose a large coefficient to reduce the number of generations required to display the effect of selection

selected_pop <- select_population(wildpop, selection_matrix,
                                  selection = selection_coefficient,
                                  pop_size = 1000,
                                  total_runtime = 100,
                                  morgan = 1,
                                  seed = 12345,
                                  write_to_file = FALSE)
```
Here, we define a selection matrix, which defines the areas of selection. Each row in the matrix contains 3 elements: the start of the area under selection, the end of the area under selection, and the ancestor which is favoured. Then, using the function select_population, which is very similar to other 'create_population' functions, we simulate the process. An extra argument is the argument 'selection', which indicates the strength of selection. Fitness of individuals is determined by their match to the area under selection, e.g. individuals without the ancestor have fitness 1, and individuals with the ancestor have fitness 1 + s. 

Obtained results can be analyzed using the function calculate_allele_frequencies, which estimates allele frequencies across the genome.
```{r allele frequencies}
freq_output <- calculate_allele_frequencies(selected_pop, 
                                            number_of_founders = number_founders,
                                            step_size = 0.001)
```
calculate_allele_frequencies returns a tibble (from the tidyverse) and can easily be plotted:
```{r plot allele frequencies}

require(ggplot2)
ggplot(freq_output, aes(x=location, y = frequency, col = as.factor(ancestor))) +
  geom_line() +
  geom_vline(xintercept = c(0.2, 0.3, 0.6, 0.7), lty = 2)
```
Alternatively, selection can be implemented from scratch, without supplying a source population:
```{r selection from scratch}
selection_matrix = matrix(ncol=3, nrow = 2)

selection_matrix[1,] = c(0.1, 0.12, 1)
selection_matrix[2,] = c(0.78, 0.8, 2)

selected_pop_2 <- create_population_selection(pop_size = 1000,
                                  number_of_founders = 10, 
                                  total_runtime = 1000,
                                  morgan = 1,
                                  select_matrix = selection_matrix,
                                  selection = 10,
                                  seed = 12345,
                                  write_to_file = FALSE)

freq_output <- calculate_allele_frequencies(selected_pop, 
                                            number_of_founders = number_founders,
                                            step_size = 0.01)

ggplot(freq_output, aes(x=location, y = frequency, col = as.factor(ancestor))) +
  geom_line() +
  geom_vline(xintercept = c(0.1, 0.12, 0.78, 0.8), lty = 2)

```

# Migration
To simulate two populations with a fixed degree of migration between them, we can use:

```{r}
pops_migration <- create_two_populations_migration(pop_size = 1000,
                                         number_of_founders = 10,
                                         total_runtime = 100,
                                         morgan = 1,
                                         seed = 1234,
                                         migration = 0.01,
                                         write_to_file = FALSE)
```
This creates two populations, where with a probability of 0.01 (e.g. 'migration') offspring in the next generation is the product of a mating event of two randomly picked individuals from the other population.

FST values drop rapidly depending on the rate of migration, migration of 0.01 already decreases FST to about 0 in 100 generations:
```{r}
FST <- calculate_fst(pops_migration$Population_1,
                 pops_migration$Population_2,
                 sampled_individuals = 10,
                 number_of_markers = 100,
                 random_markers = TRUE)
FST
```